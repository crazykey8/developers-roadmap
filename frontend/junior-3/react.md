### React

#### Reconciliation
* **Что такое? Какую функцию выполняет?**
  * Reconciliation — это процесс, с помощью которого React обновляет пользовательский интерфейс. React анализирует изменения в виртуальном DOM и сравнивает его с текущим состоянием реального DOM, чтобы минимизировать количество изменений и оптимизировать производительность.
* **Каким образом reconciliation алгоритм использует тип элемента (что происходит, если тип изменился, не изменился и т.д.)?**
  * Если тип элемента не изменился, React предполагает, что элемент может быть обновлен, а не полностью заменен. Если тип изменился, React удаляет старый элемент и создает новый. Это позволяет React эффективно обновлять и перерисовывать элементы в интерфейсе.
* **Атрибут `key`**
  * **Зачем нужен?**
    * Атрибут `key` помогает React идентифицировать какие элементы изменились, добавились или были удалены. Это упрощает процесс обновления списка и улучшает производительность.
  * **Почему лучше не использовать индекс элемента массива в качестве значения? Когда этим правилом можно пренебречь?**
    * Использование индекса в качестве `key` может привести к проблемам при изменении порядка элементов, так как это может вызвать неправильное отображение или повторное использование элементов. Лучше использовать уникальные идентификаторы. Однако, если список статичен и не изменяется, можно использовать индексы.
  * **Должно ли значение атрибута `key` быть уникальным для всего отрисованного дерева (по аналогии с html-атрибутом `id`)?**
    * Значение `key` должно быть уникальным только в пределах списка элементов, но не обязательно в пределах всего дерева компонентов.
  * **Имеется список из нескольких элементов:**
    ```javascript
    <ul>
      {list.map((text, i) => (<li key={i}>{text} <input /> </li>))}
    </ul>
    ```
    **Предположим, что в каждом инпуте содержится какой-то текст. Если добавить в начало `list` еще один элемент, то какой из инпутов окажется пустым и почему?**
    * В этом случае инпуты могут перепутаться из-за использования индекса в качестве `key`. Добавленный элемент в начало списка вызовет перерисовку, и инпуты, которые раньше были в других позициях, могут остаться пустыми, так как React будет считать их новыми элементами.

#### Performance
* **Что такое windowing или virtualizing списков?**
  * Windowing или virtualizing списков — это техника, при которой только видимая часть большого списка рендерится на экране, чтобы улучшить производительность и уменьшить использование памяти.
* **Всегда ли происходит перерисовка DOM-элемента, если `shouldComponentUpdate` вернул `true`?**
  * Да, если `shouldComponentUpdate` возвращает `true`, компонент будет перерисован. Это метод позволяет оптимизировать рендеринг, предотвращая ненужные обновления.

#### Synthetic Events
* **Что такое и зачем нужны?**
  * Synthetic Events — это абстракция над реальными браузерными событиями, предоставляемая React для обеспечения кросс-браузерной совместимости и оптимизации производительности.
* **Пусть на какое-то событие на `<input />` назначено 2 обработчика: один через атрибут `on...`, а другой через `addEventListener`.**
  * **В чем разница между добавлением обработчиков первым и вторым способом?**
    * Обработчики, назначенные через `on...` атрибуты, будут обрабатываться в рамках Synthetic Events, а те, что через `addEventListener`, будут обрабатываться напрямую, что может влиять на порядок выполнения и производительность.
  * **В каком порядке могут выполняться обработчики? От чего это зависит?**
    * Обработчики, назначенные через `on...`, будут выполняться в порядке их объявления в React. Обработчики, назначенные через `addEventListener`, выполняются в зависимости от их порядка в DOM.
  * **Может ли один из обработчиков отменить выполнение второго обработчика?**
    * Обработчик, назначенный через `on...`, может отменить выполнение другого обработчика, если используется метод `stopPropagation`. Обработчики, назначенные через `addEventListener`, также могут отменять другие обработчики с помощью `stopPropagation` и `preventDefault`.
  * **Какие проблемы могут возникнуть из-за использования обработчика, навешанного через `addEventListener`?**
    * Возможны проблемы с производительностью и несовместимость с системой Synthetic Events. Также может возникнуть путаница с порядком выполнения обработчиков и их взаимодействием.

#### Higher-Order Components (HOCs)
* **Может ли HOC оборачивать несколько компонент разом?**
  * Да, HOC может оборачивать несколько компонентов, создавая композицию компонентов с общим функционалом.
* **Зачем делать функцию, которая возвращает функцию высшего порядка, создающую HOC? Как это помогает сделать HOC композабельным?**
  * Это позволяет создавать более гибкие и настраиваемые HOCs, которые могут быть легко комбинированы с другими HOCs или функциями.
* **Какие проблемы могут возникать, если HOC не будет прокидывать входящие props дальше в потомка?**
  * Это может привести к потере функциональности или неправильному отображению, так как компоненты не получат необходимые данные и методы.
* **Как обрабатывать `displayName` при создании HOC?**
  * `displayName` следует устанавливать для HOC, чтобы упростить отладку и отображение имени компонента в инструментах разработчика.
* **Как HOC влияет на forwarded ref?**
  * HOC может не передавать рефы дальше, если они не правильно прокидываются. Используйте `React.forwardRef` для передачи рефов через HOC.
* **В чем преимущество использования HOC для получения значения из контекста перед useContext и наоборот?**
  * HOC может быть полезен, когда нужно обернуть несколько компонентов в контекст или использовать контекст в разных местах. `useContext` проще и менее громоздкий для одного компонента.

#### Render Prop
* **Что такое Render Prop? Где и как может использоваться такой приём?**
  * Render Prop — это паттерн, при котором компонент принимает функцию в качестве пропса и использует её для рендеринга. Это позволяет создавать гибкие и переиспользуемые компоненты, которые могут рендерить разный UI в зависимости от логики функции.

#### Custom Hooks
* **Как и для чего создавать пользовательские хуки?**
  * Пользовательские хуки создаются для того, чтобы извлечь и переиспользовать логику состояния и эффекты между компонентами. Это помогает избежать дублирования кода и улучшить модульность.
* **Как правильно именовать пользовательские хуки? Почему?**
  * Именование должно начинаться с префикса `use`, чтобы показать, что это хук и он может использовать другие хуки. Это также помогает соблюсти правила хуков и улучшает читаемость кода.