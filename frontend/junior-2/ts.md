### TypeScript

#### Что такое TypeScript?

**TypeScript** — это расширение JavaScript, добавляющее поддержку статической типизации. Это язык программирования, разработанный Microsoft, который компилируется в JavaScript. Он позволяет выявлять ошибки на этапе компиляции и улучшает качество кода благодаря типам данных и объектно-ориентированным концепциям.

**Проблемы, которые решает TypeScript:**
- **Ошибки во время разработки:** Позволяет обнаруживать ошибки типизации еще до выполнения кода.
- **Улучшенная автодополнение и навигация:** Предоставляет более точное автодополнение и возможности рефакторинга в редакторах кода.
- **Поддержка современного JavaScript:** Поддерживает современные возможности JavaScript, которые могут быть недоступны в старых браузерах.

#### Виды типизации

1. **Слабая/Сильная**
   - **Слабая типизация:** Язык не требует явного указания типа переменной, и автоматически преобразует типы. Пример: JavaScript.
   - **Сильная типизация:** Язык требует явного указания типов и строго следит за типами. Пример: TypeScript.

2. **Статическая/Динамическая**
   - **Статическая типизация:** Типы проверяются на этапе компиляции. Пример: TypeScript.
   - **Динамическая типизация:** Типы проверяются во время выполнения программы. Пример: JavaScript.

3. **Явная/Неявная**
   - **Явная типизация:** Программист явно указывает типы данных. Пример: TypeScript.
   - **Неявная типизация:** Язык сам определяет типы на основе присвоений и операций. Пример: JavaScript.

4. **Структурная/Номинативная**
   - **Структурная типизация:** Типы определяются по структуре и соответствию. Пример: TypeScript (тип `interface`).
   - **Номинативная типизация:** Типы определяются по имени или метке. Пример: Java.

#### Виды типизации в JavaScript и TypeScript

- **JavaScript:** Использует динамическую и неявную типизацию.
- **TypeScript:** Использует статическую и явную типизацию, а также поддерживает структурную типизацию.

#### Типы данных в TypeScript

1. **Boolean**
   - Представляет логическое значение `true` или `false`.

2. **Number**
   - Представляет числовое значение (включает целые числа и числа с плавающей запятой).

3. **String**
   - Представляет строковое значение.

4. **Null and Undefined**
   - **Null:** Представляет отсутствие значения.
   - **Undefined:** Представляет значение, которое было объявлено, но не инициализировано.

5. **Object and object**
   - **Object:** Представляет объекты, но не включает примитивные типы. 
   - **object:** Тип, который представляет все объекты, включая примитивные типы.

6. **Array**
   - Представляет массив элементов одного типа.

7. **Tuple**
   - Представляет массив фиксированной длины, где каждый элемент может иметь свой тип.

8. **Enum**
   - Позволяет определять именованные константы.

9. **Any**
   - Представляет любой тип данных. Используется для отключения проверки типов.

10. **Void**
    - Представляет отсутствие значения, обычно используется для функций без возвращаемого значения.

11. **Never**
    - Представляет тип, который никогда не возникает (например, функция, которая всегда выбрасывает исключение).

12. **Unknown**
    - Представляет значения неизвестного типа, требующие проверки перед использованием.

#### Вывод типов

**Вывод типов** (type inference) — это способность языка автоматически определять тип переменной или выражения на основе контекста. TypeScript выводит типы, если они не указаны явно, основываясь на значениях и операциях.

#### Когда TS автоматически выводит переменную типа как `any`

TypeScript может автоматически выводить переменную как `any` в случаях:
- Если тип не может быть выведен и явно не указан.
- Если используется значение или выражение, для которого тип не был определен.

#### Типы Assertions

**Type assertions** позволяют разработчику явно указать тип переменной. Это может быть полезно, но следует избегать их чрезмерного использования, так как это обходит систему типов и может привести к ошибкам.

```typescript
let someValue: any = "this is a string";
let strLength: number = (someValue as string).length; // Пример использования type assertion
```

#### Интерфейсы

**Интерфейсы** предназначены для описания структуры объектов и классов. Они позволяют задавать контракт, которому должны соответствовать объекты и классы.

#### Type Aliases

**Type Aliases** позволяют создавать новые имена для существующих типов. Они могут быть использованы для определения сложных типов или объединений.

**Отличия от интерфейсов:**
- Интерфейсы могут расширяться (расширение и объединение интерфейсов).
- Type aliases не могут быть расширены, но могут использоваться для создания сложных типов, включая объединения и пересечения.

```typescript
type Point = { x: number; y: number };
interface IPoint { x: number; y: number; }
```

#### `?` после имени свойства интерфейса или аргумента функции

`?` обозначает, что свойство или аргумент функции являются необязательными.

- `x?: number` означает, что `x` может быть `number` или `undefined`.
- `x: number | undefined` явно указывает, что `x` может быть `number` или `undefined`.

#### Постфикс `!`

Постфикс `!` используется для указания TypeScript, что значение не может быть `null` или `undefined`. Его следует избегать, чтобы не нарушать гарантии системы типов.

```typescript
class C {
  foo!: number;
}
```

#### Наследование интерфейсов

Интерфейсы могут наследоваться от других интерфейсов, а также могут наследоваться от классов, но это накладывает ограничения. Интерфейсы не могут наследоваться от конкретных реализаций классов, только от других интерфейсов.

#### Способы типизации статических и экземплярных частей класса

- **Статическая типизация:** Используйте типизацию для статических членов класса.
- **Экземплярная типизация:** Используйте типизацию для экземпляров класса.

```typescript
class MyClass {
  static staticProperty: string;
  instanceProperty: number;
}
```

#### Реализация нескольких интерфейсов и наследование от класса

Класс может реализовывать несколько интерфейсов и наследоваться от другого класса.

```typescript
class BaseClass {
  baseProperty: string;
}

interface Interface1 {
  prop1: number;
}

interface Interface2 {
  prop2: string;
}

class DerivedClass extends BaseClass implements Interface1, Interface2 {
  prop1: number;
  prop2: string;
}
```

#### Модификаторы свойств классов

- **private:** Доступен только внутри класса.
- **protected:** Доступен внутри класса и его наследниках.
- **public:** Доступен отовсюду.
- **#:** Используется для создания приватных полей в JavaScript.

#### Абстрактные классы

**Абстрактные классы** не могут быть инстанциированы напрямую и используются для определения базовой структуры и поведения для других классов. В отличие от обычных классов, абстрактные классы могут содержать абстрактные методы, которые должны быть реализованы в производных классах.

#### Объявление метода, возвращающего контекст вызова

```typescript
interface ISomething {
  getThis(): this;
}

class Something implements ISomething {
  public getThis() {
    return this;
  }
}
```

#### Hybrid Types

**Hybrid Types** используются для описания объектов, которые могут быть использованы как функции и объекты одновременно.

#### Index types

**Index types** позволяют описывать объекты, где ключи могут быть определенного типа.

- **`keyof` оператор:** Позволяет получить тип ключей объекта.

#### Mapped Types

**Mapped Types** позволяют создавать типы на основе существующих, изменяя их свойства.

```typescript
type ReadOnly<T> = {
  readonly [K in keyof T]: T[K];
};
```

#### Generics

**Generics** позволяют создавать компоненты и функции, которые могут работать с разными типами, сохраняя типовую безопасность.

- **Встроенные обобщенные интерфейсы:** `Array<T>`, `Promise<T>`, `Map<K, V>`, `Set<T>`.
- **Ограничение значений:** Используйте `extends` для ограничения значений.

```typescript
function identity<T>(arg: T): T {
  return arg;
}
```

#### Union и Intersection типы

- **Union типы:** Позволяют переменной быть одним из нескольких типов.

```typescript
type A = string | number;
```

- **Intersection типы:** Позволяют комбинировать несколько типов в один.

```typescript
type B = { name: string } & { age: number };
```

#### Narrowing

**Type Guards** — это конструкции, которые позволяют определить, какой конкретно тип используется.



- **Оператор `in`:** Проверяет наличие свойства в объекте.
- **`typeof`:** Проверяет тип примитивных значений.
- **`instanceof`:** Проверяет, является ли объект экземпляром класса.
- **Сравнение `==/===`:** Проверяет равенство значений.
- **Отрицание `!` и двойное отрицание `!!`:** Преобразует значение в boolean.

#### Assertion Functions

**Assertion Functions** — это функции, которые проверяют условие и выбрасывают исключение, если условие не выполнено.

#### Discriminated union

**Discriminated union** — это тип объединения, который использует дискриминатор для выбора типа.

- **Тип дискриминанта:** Это поле, которое определяет тип объекта.
- **Exhaustiveness checking:** Позволяет проверять, что все возможные случаи обработаны.