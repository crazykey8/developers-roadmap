### JavaScript

#### Объекты

**Что такое геттеры и сеттеры? Как ими пользоваться в JS нативным способом?**
Геттеры и сеттеры — это специальные методы, которые позволяют управлять доступом к свойствам объектов. Геттеры позволяют получить значение свойства, а сеттеры — установить значение.

Пример использования:

```javascript
const obj = {
  _value: 1,
  
  get value() {
    return this._value;
  },
  
  set value(val) {
    this._value = val;
  }
};

console.log(obj.value); // 1 (геттер)
obj.value = 10; // сеттер
console.log(obj.value); // 10
```

**Дескрипторы свойств объектов: что такое и что позволяют делать?**
Дескрипторы свойств — это объекты, которые описывают атрибуты свойств объектов, такие как `writable`, `enumerable`, `configurable`, и `value` для обычных свойств, или `get` и `set` для геттеров и сеттеров. С их помощью можно контролировать, как свойства будут вести себя.

Пример:

```javascript
const obj = {};
Object.defineProperty(obj, 'x', {
  value: 42,
  writable: false, // запретить изменение значения
  enumerable: true, // свойство будет отображаться при переборе свойств
  configurable: false // запретить удаление или изменение дескриптора
});

console.log(obj.x); // 42
obj.x = 100; // ничего не изменится, так как writable: false
console.log(obj.x); // 42
```

**Приведение объектов к примитивам: когда происходит и как работает?**
Приведение объектов к примитивам происходит в контексте, когда требуется примитивное значение, например, при использовании операторов `+`, `==` или при вызове методов, ожидающих примитивное значение. JavaScript автоматически вызывает методы `toString` или `valueOf`, чтобы получить примитивное значение из объекта.

**Как сделать так, чтобы было возможно сложение двух объектов?**

Для сложения объектов можно переопределить метод `valueOf`:

```javascript
const a = {
  x: 3,
  valueOf() {
    return this.x;
  }
};

const b = {
  x: 5,
  valueOf() {
    return this.x;
  }
};

console.log(a + b); // 8
```

**Как сделать так, чтобы следующее выражение вернуло `true`?**

Чтобы выражение `(c==1 && c==2 && c==3)` вернуло `true`, можно использовать геттер:

```javascript
const c = {
  _value: 1,
  get value() {
    return this._value++;
  },
  toString() {
    return this.value;
  }
};

console.log(c == 1 && c == 2 && c == 3); // true
```

#### Массивы

**Можно ли прервать обход элементов в методе `forEach`?**
Нет, прервать `forEach` невозможно, но можно использовать `every`, `some`, или обычный `for`/`for...of` цикл.

**Можно ли с помощью метода `indexOf` определить позицию подмассива `[3, 4]` в массиве `[1, 2, [3, 4], 5]`?**
Нет, `indexOf` ищет только точные совпадения для примитивных значений. Для поиска подмассива нужно написать собственную функцию или использовать другие методы.

**Как строку преобразовать в массив? Можно ли для строк применить методы массивов?**
Строку можно преобразовать в массив с помощью `split`:

```javascript
const str = "hello";
const arr = str.split(''); // ["h", "e", "l", "l", "o"]
```

Методы массивов можно применять к строкам, преобразовав их с помощью `Array.from` или `split`.

**Что делают, как и когда использовать следующие методы массивов:**

- `copyWithin`: Копирует часть массива на другую позицию в этом же массиве, не меняя его длину.
  
  ```javascript
  [1, 2, 3, 4, 5].copyWithin(0, 3); // [4, 5, 3, 4, 5]
  ```

- `flat`: Разворачивает вложенные массивы до указанной глубины.
  
  ```javascript
  [1, [2, [3, [4]]]].flat(2); // [1, 2, 3, [4]]
  ```

- `flatMap`: Применяет функцию к каждому элементу и затем разворачивает результат в новый массив.
  
  ```javascript
  [1, 2, 3].flatMap(x => [x, x * 2]); // [1, 2, 2, 4, 3, 6]
  ```

- `with`: (на момент написания этот метод является экспериментальным и может быть недоступен в некоторых версиях) возвращает новый массив, где элемент в указанной позиции заменен на новое значение.

  ```javascript
  const arr = [1, 2, 3];
  const newArr = arr.with(1, 4); // [1, 4, 3]
  ```

#### Функции

**Что такое "всплытие" объявления переменных, и в каком случае у функций тут появляются особенности?**
"Всплытие" (hoisting) — это поведение JavaScript, при котором объявления переменных и функций поднимаются вверх своей области видимости.

Особенность у функций: Function Declaration поднимается целиком, включая тело функции, а у переменных (var) поднимается только объявление, без присвоенного значения.

**Влияет ли директива `use strict` на "всплытие"? Как избежать "всплытия" переменных?**
`use strict` не влияет на всплытие, но делает код более строгим, например, запрещает использование необъявленных переменных.

Чтобы избежать всплытия, используйте `let` и `const` вместо `var`, так как они не всплывают.

**Что такое IIFE (immediately invoked function expression)? Какие есть способы написать IIFE и почему это так работает?**
IIFE — это функция, которая вызывается сразу после своего определения. Она создаёт новую область видимости.

Пример:

```javascript
(function() {
  console.log("IIFE");
})();
```

**Как сделать так, чтобы при вызове immediately invoked function expression сохранялся родительский контекст?**

Используйте стрелочную функцию:

```javascript
(() => {
  console.log(this); // сохраняется контекст родительской функции или объекта
})();
```

**Как использовать стандартные методы массива для ненастоящих массивов (например, вызвать `map` для `arguments`) и почему это работает?**
Нужно использовать метод `call` или `apply`, чтобы вызвать метод массива на псевдомассиве:

```javascript
function example() {
  const args = Array.prototype.map.call(arguments, x => x * 2);
  console.log(args); // [2, 4, 6]
}

example(1, 2, 3);
```

Это работает, потому что методы массива полагаются на свойства итерируемых объектов, а не на сам тип объекта.

#### Promises

**Что такое Promise? Для чего он нужен?**
Promise — это объект, представляющий результат асинхронной операции, который может быть завершен успешно или с ошибкой.

**Как создать Promise?**
Promise создаётся с помощью конструктора `Promise`, которому передаётся функция с двумя аргументами: `resolve` и `reject`.

```javascript
const promise = new Promise((resolve, reject) => {
  // асинхронная операция
});
```

- Коллбэк, передаваемый в конструктор промиса, выполняется сразу же.

**Методы `then`, `catch`, `finally`:**

- `then`: используется для обработки успешного выполнения промиса.
- `catch`: обрабатывает ошибки.
- `finally`: выполняется в любом случае после завершения промиса.

**Что такое цепочка промисов?**
Цепочка промисов — это последовательность вызовов `then`, `catch`, `finally`, где каждый последующий обработчик получает результат предыдущего.

- Коллбеки могут возвращать новые промисы или значения, что влияет на состояние следующего промиса в цепочке.

**В чем отличие между `then(resolveHandler).catch(rejectHandler)` и `then(resolveHandler, rejectHandler)`?**
- `then(resolveHandler, rejectHandler)` обрабатывает как успешное выполнение, так и ошибки в одном методе.
- `then(resolveHandler).catch(rejectHandler)` обрабатывает ошибки только после всех `then`.

**Можно ли отменить выполнение промиса?**
Нет, промисы не поддерживают отмену выполнения, но можно использовать аборты (например, `AbortController`) для отмены операций.

**Для чего нужны и как использовать следующие методы:**

- `Promise.resolve`: создает успешно завершенный промис.
- `Promise.reject`: создает промис, завершенный с ошибкой.
- `Promise.all`: ждет выполнения всех промисов и возвращает массив их результатов.
- `Promise.allSettled`: ждет выполнения всех промисов и возвращает массив их состояний.
- `

Promise.race`: возвращает первый завершенный промис (успешный или с ошибкой).
- `Promise.any`: возвращает первый успешно завершенный промис.

**В чем преимущества и недостатки коллбэков и промисов?**

- Преимущества промисов: читаемость, цепочки, обработка ошибок.
- Недостатки промисов: сложнее понять для новичков, чем простые коллбэки.

**Какое состояние и результат будут у следующего промиса и почему:**

```javascript
const promise = new Promise((resolve, reject) => {
  resolve(0);
  reject(1);
  resolve(2);
});
```

Состояние: `fulfilled` (успешное), результат: `0`. После вызова `resolve`, любые следующие вызовы `reject` или `resolve` игнорируются.

**Что такое async/await?**
`async/await` — это синтаксический сахар над промисами, позволяющий писать асинхронный код в синхронном стиле.

- `await` можно использовать только внутри функций, объявленных с `async`.
- Ошибки в `async/await` обрабатываются с помощью `try/catch`.

```javascript
async function example() {
  try {
    const result = await someAsyncFunction();
    console.log(result);
  } catch (error) {
    console.error(error);
  }
}
```