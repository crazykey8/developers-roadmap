## Данные

### 1. Какие типы данных есть в JS?
В JavaScript существуют следующие типы данных:
- **Примитивные типы**:
  - `string` (строки)
  - `number` (числа)
  - `bigint` (большие целые числа)
  - `boolean` (логический тип)
  - `undefined` (неопределённый тип)
  - `null` (нулевой тип)
  - `symbol` (символы)
- **Ссылочные типы**:
  - `object` (объекты, включая массивы, функции и другие объекты)

### 2. Какие типы в JS изменяемые, а какие нет?
- **Неизменяемые (иммутабельные)**: Примитивные типы, такие как `string`, `number`, `bigint`, `boolean`, `undefined`, `null`, и `symbol`. Они не могут быть изменены после создания.
- **Изменяемые (мутабельные)**: Ссылочные типы (`object`). Они могут быть изменены после создания, например, свойства объекта могут быть добавлены, изменены или удалены.

### 3. Что значит ссылка на переменную?
Ссылка на переменную означает, что переменная указывает на область памяти, где хранится объект. Если другая переменная присвоена ссылке, они обе будут указывать на один и тот же объект. Изменения в объекте через одну из этих переменных будут видны через другую.

### 4. Что такое `NaN`? Как проверить, что переменная - `NaN`?
`NaN` (Not-a-Number) — это специальное значение в JavaScript, которое указывает на то, что результат математической операции не является числом. Проверить, является ли переменная `NaN`, можно с помощью функции `isNaN()` или метода `Number.isNaN()` (предпочтительнее, так как он проверяет именно на `NaN`, а не на любую нечисловую сущность).

### 5. Что значит создавать переменную через конструктор или через литерал? Есть ли отличия?
Создание переменной через литерал выглядит проще и выполняется быстрее:
- Литерал: `let obj = {};`
- Конструктор: `let obj = new Object();`

Основное отличие — создание через литерал считается предпочтительным из-за более простой и понятной записи.

### 6. Когда при обращении к свойству объекта стоит использовать точечную нотацию, а когда квадратные скобки?
- **Точечная нотация** (`obj.property`) используется, когда имя свойства известно и является валидным идентификатором в JS.
- **Квадратные скобки** (`obj["property"]`) используются, когда имя свойства динамически вычисляется, является недопустимым идентификатором (например, содержит пробелы) или доступно только в виде строки.

### 7. Что произойдет, если попытаться получить несуществующее в объекте свойство?
Если попытаться получить несуществующее свойство объекта, результатом будет `undefined`.

### 8. Что делает метод `hasOwn`/`hasOwnProperty`?
Метод `hasOwnProperty()` проверяет, является ли указанное свойство непосредственным (т.е., определённым непосредственно на объекте, а не унаследованным через прототип) и возвращает `true` или `false`.

### 9. Когда использовать `null`, а когда `undefined`?
- **`null`** используется, когда разработчик явно хочет указать, что значение отсутствует, но известно.
- **`undefined`** означает, что значение переменной не было присвоено или свойство не существует.

### 10. Какие есть способы создания глобальных переменных?
- Создание без ключевого слова `var`, `let`, или `const` (не рекомендуется): `globalVar = 'value';`
- Объявление переменной с использованием `var` вне всех функций (в браузере): `var globalVar = 'value';`
- Использование глобального объекта (`window` в браузере или `global` в Node.js): `window.globalVar = 'value';`

### 11. Для чего нужна директива `use strict`?
`"use strict"` включает строгий режим, который добавляет дополнительные проверки и ограничения в коде, предотвращая некоторые ошибки, такие как неявное создание глобальных переменных или использование зарезервированных слов.


## Выражения

### 1. Что такое выражения и инструкции? В чем отличия между ними?
- **Выражение** — это комбинация значений, переменных и операторов, которая возвращает значение. Пример: `2 + 2`.
- **Инструкция** — это фрагмент кода, который выполняет действие и завершает свою работу; может состоять из одного или нескольких выражений. Пример: `let x = 2 + 2;`.

### 2. Чем отличаются `var`, `let`, `const`? Почему использование `const` может быть предпочтительнее?
- **`var`**: Имеет функциональную область видимости, переменная может быть переопределена, допускает повторное объявление и имеет автоматическое поднятие (`hoisting`).
- **`let`**: Имеет блочную область видимости, переменная может быть переопределена, но не допускает повторное объявление.
- **`const`**: Имеет блочную область видимости, переменная не может быть переопределена и не допускает повторное объявление. `const` предпочтительнее для неизменяемых переменных, так как предотвращает их случайное изменение.

### 3. Что такое тернарный оператор?
Тернарный оператор (`?:`) — это сокращённая форма записи условного выражения:
```javascript
condition ? expressionIfTrue : expressionIfFalse;
```

### 4. Что делает оператор `for..in`? Какие имеются особенности при использовании этого оператора с массивами?
`for..in` итерирует по перечисляемым свойствам объекта. Особенности при использовании с массивами:
- Перебирает индексы (ключи), а не значения.
- Может перебирать и унаследованные свойства, что может привести к неожиданным результатам при использовании с массивами. Для массивов предпочтительнее использовать `for..of` или методы массивов.

### 5. Как безопасно проверить, что переменная существует (была объявлена), и не словить ReferenceError?
Использовать конструкцию `typeof`:
```javascript
if (typeof variable !== 'undefined') {
  // переменная существует
}
```

## Массивы

### 1. Способы создания массивов (литерал, конструктор, фабричные методы `Array.from()` и `Array.of()`)
- **Литерал**: `let arr = [];`
- **Конструктор**: `let arr = new Array();`
- **`Array.from()`**: Создаёт массив из итерируемого или подобного массиву объекта.
- **`Array.of()`**: Создаёт массив с переданными аргументами.

### 2. Удаление элемента из массива (какие есть способы и в чем особенности)
- **`delete array[index]`**: Удаляет элемент, но не изменяет длину массива, оставляя пустое место (`undefined`).
- **`splice(index, 1)`**: Удаляет элемент и сдвигает остальные элементы, изменяя длину массива.
- **`pop()`/`shift()`**: Удаляют элементы с конца/начала массива соответственно.

### 3. Свойство `length` у массива

#### 3.1 Какое значение будет у свойства `length` массива `a` и почему?
```javascript
const a = [1, 2, 3];
a[10] = 4;
```
Значение `length` будет `11`, так как массив теперь содержит элементы с индексами от 0 до 10, хотя некоторые из них пустые.

#### 3.2 Что будет, если переприсвоить новое значение?
Если присвоить `a.length = 5;`, элементы с индексами от 5 до 10 будут удалены, а `length` станет равным 5.

#### 3.3 Влияет ли на `length` удаление элемента посередине массива? Какие способы удаления элементов влияют на длину, а какие нет?
Удаление через `splice()` или сокращение `length` влияет на длину массива. `delete` не изменяет `length`, оставляя пустые слоты.

### 4. Как проверить, что в переменной лежит массив?
Использовать метод `Array.isArray(variable)`.

### 5. Что делают, как и когда использовать следующие методы:
- **`slice`**: Возвращает новый массив, содержащий копию части исходного массива, не изменяя его.
- **`at`**: Возвращает элемент массива по индексу, поддерживает отрицательные индексы.
- **`reverse`**: Изменяет порядок элементов в массиве на обратный, изменяя исходный массив.
- **`toReversed`**: Возвращает новый массив с обратным порядком элементов, не изменяя исходный массив.
- **`splice`**: Изменяет массив, добавляя или удаляя элементы, возвращает удалённые элементы.
- **`toSpliced`**: Возвращает новый массив с внесёнными изменениями, не изменяя исходный массив.
- **`reduce`**: Применяет функцию к каждому элементу массива (слева направо) с аккумулятором, возвращая единое значение.
- **`sort`**: Сортирует элементы массива на месте и возвращает его.
- **`toSorted`**: Возвращает новый отсортированный массив, не изменяя исходный массив.
- **`filter`**: Возвращает новый массив, содержащий элементы, которые удовлетворяют условию.
- **`map`**: Возвращает новый массив, функция будет вызвана для каждого элемента массива по порядку.
- **`forEach`**: Выполняет функцию для каждого элемента массива, не возвращая значения.
- **`some`**: Возвращает `true`, если хотя бы один элемент массива удовлетворяет условию.
- **`every`**: Возвращает `true`, если все элементы массива удовлетворяют условию.

## Функции

### 1. Какие есть 4 шаблона вызова функции, которые задают контекст выполнения этой функции?
- Вызов как метода объекта: `obj.method()`
- Вызов как обычной функции: `func()`
- Вызов с помощью `call`/`apply`: `func.call(obj)` или `func.apply(obj)`
- Вызов как конструктора: `new Func()`

#### 1.1 Как директива `use strict` влияет на `this` внутри функции?
В строгом режиме значение `this` для вызова обычной функции будет `undefined`, если явно не указано другое значение. В нестрогом режиме `this` будет глобальным объектом (например, `window` в браузере).

### 2. Какой наиболее простой паттерн, позволяющий облегчить читаемость функции, когда у нее огромное количество аргументов?
Использование объекта в качестве аргумента, содержащего все необходимые параметры:
```javascript
function myFunction({ param1, param2, param3 }) {
  // ...
}
```

### 3. Как получить все аргументы функции (включая те, что не объявлены, но все-таки были переданы)?
Использовать объект `arguments` (в функциях, не использующих стрелочную функцию) или оператор `...rest`:
```javascript
function myFunction(...args) {
  // args - массив всех аргументов
}
```

### 4. Что такое рекурсия? Когда удобно её использовать?
Рекурсия — это когда функция вызывает саму себя. Удобна для задач, которые можно разбить на подзадачи того же типа, например, обход дерева, решение задач с вложенными структурами и др.

### 5. Что такое замыкания, и в каких случаях они могут быть полезны? Как сохранить состояние с помощью замыкания, и для чего это состояние может быть использовано?
Замыкание — это функция, которая «замыкает» и сохраняет доступ к переменным внешней функции, даже после того, как внешняя функция завершила выполнение. Полезно для создания приватных переменных и функций.

### 6. Как реализовать функцию `bind`?
Функция `bind` создаёт новую функцию, которая при вызове устанавливает `this` на указанное значение и передаёт любые последующие аргументы.
Пример реализации:
```javascript
Function.prototype.myBind = function(context, ...args) {
  const func = this;
  return function(...newArgs) {
    return func.apply(context, [...args, ...newArgs]);
  };
};
```

### 7. Решить такую вот проблему: пускай у нас есть массив ссылок, и наша задача — сделать так, чтобы при клике на каждую выводился `alert`ом ее порядковый номер. Первое решение, что приходит в голову, выглядит так:
```javascript
for (var i = 0; i < links.length; i++) {
     links[i].onclick = function() {
        alert(i);
     }
}
```
На деле же оказывается, что при клике на любую ссылку выводится одно и то же число — значение `links.length`. Почему так происходит и как эту гадость исправить?
Причина в том, что переменная `i` в замыкании сохраняет своё последнее значение, равное `links.length`. Исправить это можно, используя замыкание или `let`:
```javascript
for (let i = 0; i < links.length; i++) {
    links[i].onclick = function() {
        alert(i);
    }
}
```

### 8. Что такое callback (функция обратного вызова)? Когда они обычно применяются?
Callback — это функция, передаваемая другой функции в качестве аргумента и вызываемая после завершения основной операции. Применяется в асинхронных операциях (например, запросы к серверу, таймеры).

### 9. Что такое каррирование?
Каррирование — это преобразование функции с множеством аргументов в функцию, которая принимает один аргумент и возвращает другую функцию, принимающую следующий аргумент, и так далее.
```javascript
sum(2)(3) // 5

function curry(func) {
  return function curried(...args) {
    if (args.length >= func.length) {
      return func.apply(this, args)
    } else {
      return function(...args2) {
        return curried.apply(this, args.concat(args2))
      }
    }
  }
}
```

### 10. Что такое частичное применение?
Частичное применение — это создание новой функции с фиксированными аргументами из существующей функции, оставляя некоторые параметры для последующего вызова.
```javascript
// обобщенная функция
userHasRole(operator, 'ADMIN')
// функция частоиспользуемая чтобы проверить роль
clientHasRole('ADMIN')
// функция частичная применение чтобы проверить роль админа. может использована быть везде
isClientAdmin()

```

### 11. Что такое мемоизация?
В программировании мемоизация - это метод оптимизации, который делает приложения более эффективными и, следовательно, более быстрыми. Он делает это, сохраняя результаты вычислений в кэше и извлекая ту же информацию из кэша в следующий раз, когда она потребуется, вместо того, чтобы вычислять ее снова.

Проще говоря, метод состоит в том, чтобы сохранить в кэше выходные данные функции и заставить функцию проверять, находится ли каждое требуемое вычисление в кэше, прежде чем вычислять его.

Кэш - это просто временное хранилище данных, в котором хранятся данные, чтобы будущие запросы на эти данные могли обслуживаться быстрее.

Мемоизация - это простой, но мощный трюк, который может помочь ускорить наш код, особенно при работе с повторяющимися и тяжелыми вычислительными функциями.
```javascript
const memo = fn => {
  let memory = {}

  return (data) => {
    if (data in memory) {
      return memory[data]
    } else {
      const result = fn(data)
      memory[data] = result
      return result
    }
  }
}

const square = memo(num => num * num)
```

## Прототипы

### 1. Что такое функция-конструктор? Как их создавать и как ими пользоваться?
Функция-конструктор — это специальная функция для создания и инициализации объектов. Используется с `new`:
```javascript
function Person(name, age) {
    this.name = name;
    this.age = age;
}

const person = new Person('John', 30);
```

### 2. Что такое прототип? Какие возможности имеет/дает?
Прототип — это объект, из которого другие объекты наследуют свойства и методы. Все объекты в JavaScript могут иметь прототип, который предоставляет доступ к унаследованным методам и свойствам.

### 3. Как работает свойство `.prototype`?
Свойство `.prototype` присутствует у функций-конструкторов и определяет объект, который будет являться прототипом для всех объектов, созданных этой функцией.

### 4. Почему методы объекта лучше хранить в прототипе, а не в самом объекте?
Методы, хранящиеся в прототипе, не дублируются для каждого экземпляра объекта, что экономит память и облегчает обновление логики для всех экземпляров.

### 5. Можно ли создать инстанс функции через конструктор? И если да, то как, а если нет, то какой бы интерфейс вы реализовали бы для этой задачи?
Да, можно создать инстанс функции через конструктор, используя оператор `new`:
```javascript
function MyConstructor() {
    this.property = 'value';
}

const instance = new MyConstructor();
```

### 6. Как создать объект, который ни от чего не наследуется?
Использовать `Object.create(null)`:
```javascript
const obj = Object.create(null);
```

### 7. Какие 3 (как минимум) способа есть отнаследоваться в JavaScript-е? В чем отличия и нюансы?
- **Через прототипы**:
  ```javascript
  Child.prototype = Object.create(Parent.prototype);
  ```
- **Использование `class` и `extends`**:
  ```javascript
  class Child extends Parent { ... }
  ```
- **Миксины** (смесь функциональности из нескольких объектов):
  ```javascript
  Object.assign(Child.prototype, Parent.prototype);
  ```

### 8. Как объявить приватное поле класса в JS?
Использовать `#` перед именем поля:
```javascript
class MyClass {
    #privateField = 10;
}
```

### 9. Как в переопределенном методе у наследующего класса вызвать переопределяемый метод родительского?
Использовать `super()`:
```javascript
class Employee extends Person {
    getFullName() {
        return super.getFullName() + this.position;
    }
}
```

### 10. Какие есть способы навсегда привязать метод класса к его инстансу (чтобы `this` всегда был текущим экземпляром класса)?
- Использовать `bind` в конструкторе:
  ```javascript
  this.method = this.method.bind(this);
  ```
- Использовать стрелочную функцию:
  ```javascript
  method = () => {
      // ...
  };
  ```